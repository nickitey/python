# Два объекта a и b считаются различными, если a is b равно False. Вашей программе доступна переменная с названием
# objects, которая ссылается на список, содержащий не более 100 объектов. Выведите количество различных объектов в
# этом списке. Формат ожидаемой программы:
# ans = 0
# for obj in objects: # доступная переменная objects
#     ans += 1
# print(ans)
# Примечание: Количеством различных объектов называется максимальный размер множества объектов, в котором любые
# два объекта являются различными.

# Рассмотрим пример:
# objects = [1, 2, 1, 2, 3] # будем считать, что одинаковые числа соответствуют одинаковым объектам,
# а различные – различным
# Тогда все различные объекты являют собой множество {1, 2, 3}. Таким образом, количество различных объектов равно трём.


def get_unique_elems(lst):
    result = []
    for elem in lst:
        if elem not in result:
            result.append(elem)
    return len(result)


assert get_unique_elems([1, 2, 1, 2, 3]) == 3
assert get_unique_elems([[], [], [], True, 1, 2, 3]) == 4
assert get_unique_elems([1, 2, 1, 5, True, False, True, 'false', [], [1, 2], [1, 2]]) == 7

print('all tests passed')


# Мои выводы: оператор in работает по принципу ==, т.е. сравнивает значения, но не проверяет действительно
# уникальность объекта. То есть [] is [] -> False на самом деле, но [] == [], поэтому функция добавив в итоговый
# список один пустой список, все остальные списки пропускает. А еще оператор in лихо приравнивает 1 к True,
# из-за чего я с легкой ноткой ностальгии вспомнил приведение типов данных в JS.
# Поняв это, я поставил сначала перед собой задачу сделать функцию, которая будет использовать оператор is.


def get_also_unique(lst):
    result = []
    for elem in lst:
        elem_id = id(elem)
        if elem_id not in result:
            result.append(elem_id)
    return len(result)


assert get_also_unique([1, 2, 1, 2, 3]) == 3
assert get_also_unique([[], [], [], True, 1, 2, 3]) == 7
assert get_also_unique([1, 2, 1, 5, True, False, True, 'false', [], [1, 2], [1, 2]]) == 9
assert get_also_unique([1, 2, 0, 3, 4, 1, True, True, False, [True], None, [None, 1, True], {None},
                        {1: None}, [False, 1], {345}, {345}, 1, [2], 1, [2], 3, bin(1), bin(3),
                        '0b1', '0b11', 0b11, 0b1]) == 21

print('These tests also passed')

# Я так и не смог придумать вариант с использованием оператора is. Сравнивать элементы путем перебора и сравнения их
# с другими элементами исходного списка бессмысленно - у меня будет как минимум одно совпадение, а может и не одно,
# как это поможет мне добавлять уникальные элементы в итоговый список, я так и не понял.
# Пытался перебрать исходный список и список результат, типа, если элемент исходного списка встречается в итоговом
# списке, то пропускаем его. Но резонно столкнулся с тем, что интерпретатор не перебирает пустой список
# Да и в целом при попытке двойного перебора элементов компьютер стартовал в космос, а оперативная память
# РЕЗКО заканчивалсь (все 16 гб)
