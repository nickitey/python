# Лямбда функции предоставляют нам удобный способ создать функцию «прямо на месте».
# Но иногда, когда нужно создавать много однотипных лямбда функций, еще удобнее будет создать функцию,
# которая будет их генерировать.
# Реализуйте функцию mod_checker(x, mod=0), которая будет генерировать лямбда функцию от одного аргумента y,
# которая будет возвращать True, если остаток от деления y на x равен mod, и False иначе.

# Пример использования:
# mod_3 = mod_checker(3)
# print(mod_3(3)) # True
# print(mod_3(4)) # False
# mod_3_1 = mod_checker(3, 1)
# print(mod_3_1(4)) # True


def mod_checker(x, mod=0):  # Функция mod_checker принимает два аргумента: x и mod (по умолчанию mod == 0)
    return lambda y: y % x == mod  # а затем возвращает функцию, куда поставляет значения x и mod
# При этом поскольку lambda-функция должна быть "функциональной", т.е. работать с разными аргументами,
# значение у остается "незаполненным", оно "заполнится" непосредственно при вызове lambda-функции
# и передаче в нее аргумента вместо у


assert mod_checker(3)(3) is True
# Т.е. функция mod_checker(3) подставляет вместо x значение 3, вместо mod - 0,
# и возвращает lambda-функцию следующего вида:
# lambda y: y % 3 == 0
# При двух вызовах функции с разными аргументами аргумент/аргументы в первых скобках относятся к функции
# mod_checker, второй аргумент - к lambda-функции, которая принимает его как аргумент "y"
# Вторая 3 является аргументом для lambda-функции, т.е. второй вызов с аргументов "3" на самом деле
# запускает функцию вида lambda 3(y): 3(y) % 3(x) == 0(mod)

assert mod_checker(3)(4) is False
assert mod_checker(3, 1)(4) is True

print('It\'s ok!')
