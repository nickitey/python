# Напишите программу, которая считывает строку с числом n, которое задаёт количество чисел, которые нужно считать.
# Далее считывает n строк с числами x[i], по одному числу в каждой строке. Итого будет n+1 строк.
# При считывании числа x программа должна на отдельной строке вывести значение f(x).
# Функция f(x) уже реализована и доступна для вызова.
# Функция вычисляется достаточно долго и зависит только от переданного аргумента x.
# Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.

# Sample Input:
# 5
# 5
# 12
# 9
# 20
# 12
# Sample Output:
# 11
# 41
# 47
# 61
# 41
def f(x):  # В самом задании никакой функции не было, если что, это я так, заглушку поставил
    return x


# Считайте, что функция f(x) уже определена выше. Определять её отдельно не требуется.
# task29

x = int(input())
lst = []
length = x
while len(lst) < length:
    x = int(input())
    lst.append(x)
result = {}
for x in lst:
    if x not in result:
        result[x] = f(x)
        print(result[x])
    else:
        print(result[x])


# Здесь ограничение на время работы кода, я не знаю, как такое тестировать, обычная проверка на ввод и вывод здесь
# бесполезна. Принцип работы кода, думаю, понятен. Программа сначала накапливает значения с клавиатуры по условиям
# задачи, а затем проводит с ними некоторые вычисления. Суть задачи - придумать, как сэкономить время на выполнении
# функции со всеми накопленными элементами. При переборе списка накопленных элементов создается словарь элементов
# `key: value`, где key = элемент списка == аргумент функции, value = возвращаемое функцией значение. Каждый элемент
# массива при переборе проверяется, передавался ли он уже в функцию, если нет, то он передается в функцию и
# записывается в словарь вместе с результатом работы функции, если в итоговом словаре такой ключ уже есть,
# возвращается значение по ключу-аргументу.
